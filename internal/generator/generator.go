package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/elliot40404/mailc/internal/parser"
	"github.com/elliot40404/mailc/internal/util"
)

func GenerateCode(templates []*parser.ParsedTemplate, outputDir, version string) error {
	for _, pt := range templates {
		if err := generateTemplateCode(pt, outputDir, version); err != nil {
			return fmt.Errorf("generating code for %s: %w", pt.FilePath, err)
		}
	}
	return nil
}

func generateTemplateCode(pt *parser.ParsedTemplate, outputDir, version string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by mailc. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// Version: mailc %v\n\n", version))

	// TODO: make configurable
	buf.WriteString("package emails\n\n")

	imports := collectImports(pt)
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			switch imp {
			case "html/template":
				buf.WriteString("\thtmltemplate \"html/template\"\n")
			case "text/template":
				buf.WriteString("\ttexttemplate \"text/template\"\n")
			default:
				buf.WriteString(fmt.Sprintf("\t%q\n", imp))
			}
		}
		buf.WriteString(")\n\n")
	}

	prefixedTypeName := make(map[string]string)
	baseName := strings.TrimSuffix(filepath.Base(pt.FilePath), filepath.Ext(pt.FilePath))
	// Build a safe exported function/type prefix from filename
	funcPrefix := util.MakeExportedName(baseName)
	funcName := funcPrefix + "Email"
	for _, s := range pt.Structs {
		typeName := funcName + s.Name
		prefixedTypeName[s.Name] = typeName
		buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		for _, f := range s.Fields {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", f.Name, f.Type))
		}
		buf.WriteString("}\n\n")
	}

	mainStructName := funcName + "Data"
	resultStructName := funcName + "Result"
	constName := util.LowerFirst(funcName) + "HTMLTemplate"
	subjectConstName := util.LowerFirst(funcName) + "SubjectTemplate"

	buf.WriteString(fmt.Sprintf("type %s struct {\n", mainStructName))
	for _, s := range pt.Structs {
		buf.WriteString(fmt.Sprintf("\t%s %s\n", s.Name, prefixedTypeName[s.Name]))
	}
	for _, v := range pt.Variables {
		fieldName := util.UpperFirst(v.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, v.Type))
	}
	buf.WriteString("}\n\n")

	// Result struct aggregates subject and html
	buf.WriteString(fmt.Sprintf("type %s struct {\n\tSubject string\n\tHTML string\n}\n\n", resultStructName))

	processedHTML := insertLeadingDots(pt, strings.TrimSpace(pt.HTML))
	buf.WriteString(fmt.Sprintf("const %s = `%s`\n", constName, processedHTML))
	subjectTrimmed := strings.TrimSpace(pt.Subject)
	if subjectTrimmed != "" {
		processedSubject := insertLeadingDots(pt, subjectTrimmed)
		buf.WriteString(fmt.Sprintf("const %s = `%s`\n\n", subjectConstName, processedSubject))
	} else {
		buf.WriteString("\n")
	}

	buf.WriteString(fmt.Sprintf("func %s(data *%s) (result %s, err error) {\n", funcName, mainStructName, resultStructName))
	buf.WriteString(fmt.Sprintf("\tbodyTmpl, err := htmltemplate.New(\"%s\").Parse(%s)\n", baseName, constName))
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn result, fmt.Errorf(\"parse body template: %w\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\tvar bodyBuf bytes.Buffer\n")
	buf.WriteString("\tif err := bodyTmpl.Execute(&bodyBuf, data); err != nil {\n")
	buf.WriteString("\t\treturn result, fmt.Errorf(\"render body: %w\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\tresult.HTML = bodyBuf.String()\n\n")

	if subjectTrimmed != "" {
		buf.WriteString(fmt.Sprintf("\tsubjTmpl, err := texttemplate.New(\"%s_subject\").Parse(%s)\n", baseName, subjectConstName))
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn result, fmt.Errorf(\"parse subject template: %w\", err)\n")
		buf.WriteString("\t}\n\n")
		buf.WriteString("\tvar subjBuf bytes.Buffer\n")
		buf.WriteString("\tif err := subjTmpl.Execute(&subjBuf, data); err != nil {\n")
		buf.WriteString("\t\treturn result, fmt.Errorf(\"render subject: %w\", err)\n")
		buf.WriteString("\t}\n\n")
		buf.WriteString("\tresult.Subject = subjBuf.String()\n")
	}

	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting generated code: %w", err)
	}

	outFile := filepath.Join(outputDir, strings.ToLower(baseName)+".email.go")
	if err := os.WriteFile(outFile, formatted, 0o600); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	return nil
}

func collectImports(pt *parser.ParsedTemplate) []string {
	importSet := map[string]struct{}{
		"bytes":         {},
		"fmt":           {},
		"html/template": {},
	}
	// Only include text/template when a subject is present
	if strings.TrimSpace(pt.Subject) != "" {
		importSet["text/template"] = struct{}{}
	}
	for _, typ := range pt.Types {
		if typ.Type == "time.Time" {
			importSet["time"] = struct{}{}
		}
	}
	imports := make([]string, 0, len(importSet))
	for imp := range importSet {
		imports = append(imports, imp)
	}
	sort.Strings(imports)
	return imports
}

func insertLeadingDots(pt *parser.ParsedTemplate, s string) string {
	if s == "" {
		return s
	}
	oldnew := make([]string, 0, len(pt.Structs)+len(pt.Variables))
	for _, st := range pt.Structs {
		name := st.Name
		oldnew = append(oldnew, "{{"+name, "{{ ."+name)
		oldnew = append(oldnew, "{{ "+name, "{{ ."+name)
		oldnew = append(oldnew, "{{-"+name, "{{- ."+name)
		oldnew = append(oldnew, "{{- "+name, "{{- ."+name)
	}
	for _, v := range pt.Variables {
		capName := util.UpperFirst(v.Name)
		oldnew = append(oldnew, "{{"+v.Name, "{{ ."+capName)
		oldnew = append(oldnew, "{{ "+v.Name, "{{ ."+capName)
		oldnew = append(oldnew, "{{-"+v.Name, "{{- ."+capName)
		oldnew = append(oldnew, "{{- "+v.Name, "{{- ."+capName)
	}
	if len(oldnew) == 0 {
		return s
	}
	r := strings.NewReplacer(oldnew...)
	return r.Replace(s)
}
